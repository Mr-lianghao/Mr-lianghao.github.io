{"meta":{"title":"Mr.Okey","subtitle":null,"description":"��Ȼ�ഺ��ס������������ã�","author":"Haozi","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2017-07-20T08:05:31.000Z","updated":"2017-07-20T08:05:31.730Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2017-07-20T06:49:47.000Z","updated":"2017-07-20T06:49:47.255Z","comments":true,"path":"about/index-1.html","permalink":"http://yoursite.com/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2017-07-20T05:33:16.001Z","updated":"2017-07-20T05:33:16.001Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于作者 Haozi Web后台开发、Java开发者 Email：hao442986@gmail.com 微博：SirOkey"},{"title":"Categoriescloud","date":"2017-07-20T07:41:26.000Z","updated":"2017-07-20T08:01:44.471Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-20T06:50:12.000Z","updated":"2017-07-20T06:50:12.955Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"works","date":"2017-07-20T06:50:00.000Z","updated":"2017-07-20T06:50:00.195Z","comments":true,"path":"works/index.html","permalink":"http://yoursite.com/works/index.html","excerpt":"","text":""}],"posts":[{"title":"svn使用教程","slug":"svn使用教程","date":"2017-08-04T10:29:10.000Z","updated":"2017-08-04T11:29:10.742Z","comments":true,"path":"2017/08/04/svn使用教程/","link":"","permalink":"http://yoursite.com/2017/08/04/svn使用教程/","excerpt":"svn简介-为什么要使用svn在编写程序的过程中，每个程序员都会生成很多不同的版本，这就需要程序员有效的管理代码，在需要的时候可以迅速，准确取出相应的版本。","text":"svn简介-为什么要使用svn在编写程序的过程中，每个程序员都会生成很多不同的版本，这就需要程序员有效的管理代码，在需要的时候可以迅速，准确取出相应的版本。 Subversion是什么？它是一个自由/开源的版本控制系统，一组文件存放在中心版本库，记录每一次文件和目录的修改，Subversion允许把数据恢复到早期版本，或是检查数据修改的历史，Subversion可以通过网络访问它的版本库，从而使用户在不同的电脑上进行操作。 一：SVN服务器搭建和使用。1.首先来下载和搭建SVN服务器下载地址如下: http://subversion.apache.org/packages.html，进入网址后，滚动到浏览器最底部看到如下截图： 个人认为最好用VisualSVN server 服务端和 TortoiseSVN客户端搭配使用. 点开上面的VisualSVN连接,下载VisualSVN server,下载完成后双击安装，如下图： 点击Next下一步，如下： 然后再点击Next项，下一步，如下： 点击【Next】 如下： Location是指VisualSVN Server的安装目录,Repositorys是指定你的版本库目录.Server Port指定一个端口,Use secure connection勾山表示使用安全连接,点击Next,进入下一步,如下图: 再点击【Install】点击【Finish】即可完成安装。安装完成后,启动VisualSVN Server Manager,如图: 可以在窗口的右边看到版本库的一些信息,比如状态,日志,用户认证,版本库等.要建立版本库,需要右键单击左边窗口的Repositores,如下图: 在弹出的右键菜单中选择Create New Repository或者新建-&gt;Repository: 进入下一步，如下图： 点击【下一步】，如下图： 点击【create】，如下图： 点击【Finish】即可完成基本创建。 2. checkout项目文件。新建或者进入目录下(比如qianduan1)，右键 –&gt; Svn Checkout –&gt; 其中URL我可以在SVN服务器获取到，我在myRepositories下右键新建文件 qianduan文件被建立，然后比如我这样右键 –&gt; copy下 即可。 将复制的版本库URL粘贴上,如下图： 点击【ok】按钮后，就可以检索出来，如下： 如下图： 注意事项： .svn这个隐藏目录记录着两项关键信息：工作文件的基准版本和一个本地副本最后更新的时间戳，千万不要手动修改或者删除这个.svn隐藏目录和里面的文件!!,否则将会导致你本地的工作拷贝(静态试图)被破坏，无法再进行操作。 3. TortoiseSVN图标介绍 一个新检出的工作复本使用绿色的对勾重载，表示Subversion状态正常。 在你开始编辑一个文件之后，状态就变成了已修改，而图标重载已变成了红色感叹号。通过这种方式，你可以很容易地看出那些文件从你上次更新工作复本被修改过，且需要提交。 如果在提交的过程中出现了冲突，图标就会变成了黄色感叹号。 加号告诉你有一个文件或者目录已经被计划加入到版本控制中。 4. TortoiseSVN Client基础操作:4.1 SVN检出(SVN Checkout) 在文件夹或者目录下单击右键 –&gt; 选择SVN检出，如下图所示 点击后，在弹开窗口的版本库url框中输入版本库的目录地址，然后点击确定，如下图 再点击ok按钮后，如下图：在弹出的对话框中输入用户名和密码，验证成功后，项目文件开始从远程服务器下载到本地工作目录中。 点击ok按钮后，即可获取完成 4.2 增加(Add)在test项目文件下，新建一个b.txt文件，提交到版本库的方法如下2种： 先提到变更列表中，再commit到配置库中，选择新增文件，右键SVN菜单执行“Add“操作提交到”变更列表中”，然后右键SVN菜单执行”SVN Commit”提交到版本库中。 不提交到变更列表中，而是直接commit配置库中，选择该文件，右键svn菜单执行”SVN Commit”操作。 4.3 删除(Delete)如果被删除的文件还未入版本库，则可以直接使用操作系统的删除操作删除该文件。 如果被删除的文件已入版本库，则删除的方法如下： 选择被删除文件，右键svn菜单执行”delete”操作，然后选择被删除文件的父目录，右键svn菜单执行”SVN Commit”.使用操作系统的删除操作删除该文件，然后选择被删除文件的父目录，右键svn菜单执行”SVN Commit”,在变更列表中选择被删除的文件。如下图： 4.4 改名(Rename)修改文件名，选中需要重命名的文件或文件夹，然后右键“TortoiseSVNàRename“，在弹出的对话框中输入新名称，点击”ok”按钮，并将修改文件名后的文件或文件夹通过 “SVN Commit”提交到SVN服务器上。 4.5 SVN还原(SVN Revert)右击想要回退的文件或者文件夹，在TortoiseSVN弹出菜单中选择”Update to reversion…” 然后会弹出一个窗口，如下： 比如说我们要回退到第10个版本只需要在Revision中填写相应的版本号，然后点击ok即可。 4.6 检查更新(Check for modifications)此功能可以显示你所做的修改有哪些还没有提交的，此功能不光能看到对文件的修改变化，所有的变化都能看到，包括增加文件或者目录，删除文件或者目录，移动文件或者目录等，如果你点击了检查版本库，那你还可以看到版本库里的改动，既别人提交了哪些文件的改动，你还没更新到本地，如下： 4.7 SVN更新(SVN Update)更新本地代码与SVN服务器上最新的版本一致，只要在需要更新的文件夹上点击右键或者在文件下空白处点击右键，选择”SVN Update” (获取指定版本中的内容，点击右键执行SVN菜单中的“Update to reversion“)，就可以了。 4.7.1 如何解决冲突文件对于每个冲突的文件Subversion在你的目录下放置了三个文件：如下： 为什么会产生冲突代码呢？原因很简单就是因为不同的人，同时修改了同一个文件的同一个地方，这时候，他提交了，我没有提交，我就提交不了，这个时候我们要进行先更新，然后在进行提交即可，那如果产生冲突，会生成如上3个文件。 解决方案如下： 进行提交，还是提交不了，如下所示： 为什么？因为冲突会产生上面的三个文件，有上面3个文件存在肯定提交不了，这三个文件代码及解释如下： 1.txt.mine 是冲突前自己的文件。可以看下内容如下： aaaasdf11222333 dderderder 2. 1.txt.r4 是冲突前本地的版本文件 内容如下：aaaasdf11222333 3. 1.txt.r5 是别人赶在你之前提交的版本 内容如下： b其中,&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.mine …..=======之间的代码是你自己的，而======……&gt;&gt;&gt;&gt;&gt;&gt;&gt;.r5是别人与你冲突的代码部分这样就不难理解为什么会产生冲突这种奇怪的东西了，因为你们修改的同一块代码，当然会产生冲突。 解决方案如下： 假如我现在的1.txt中的冲突内容如下： &lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine 6666666666666600000 ======= 66666666666aaaaaaaaaa666 &gt;&gt;&gt;&gt;&gt;&gt;&gt; .r16 前面说过 &lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine …… ====== ……之间的代码是我未产生冲突之前修改的代码，======= ………&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r16 这中间……的代码是别人与我冲突代码的部分，从上面的代码可以看到 aaaaaaaaa是我同事新增的 ,00000是我后增加的。 使用revert(回滚)操作，该操作表示用户放弃自己的更新代码，然后直接提交，这个时候你的代码就会使服务器上最新的代码，即A用户提交的新代码，你的代码不会被提交，如下所示： 点击ok按钮后 可以看到其他三个文件都自动删掉了，1.txt代码变成如下代码：66666666666aaaaaaaaaa666也就是a用户提交的代码，我自己更新的代码需要自己动手复制进去即可提交commit。 假如我现在3.txt产生冲突代码如下： &lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine333333338888888888888=======3333cccccccccc3333&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r16 通过第一点我们知道，333333338888888888888这个内容是我修改后，未产生冲突之前的内容，3333cccccccccc3333这个代码是A用户提交的代码，从上面得知 A用户新增内容是ccccccc，而我新增的内容是8888888。那么第二种解决方法如下： 选择文件-&gt;右键Editconficts：这种方法需要冲突双方经过协商之后将代码更改统一之后再提交。不仅解决了冲突而且还保证了代码是正确的，因为只有一方的代码被提交. 如上图所示，红色的部分是冲突代码：theirs表示当前服务器端最新的代码，Mine表示自己修改后的代码，Merged表示合并后的代码。点击红色后右键选择：use this text block就可以将该部分代码作为合并后的代码 接下来再说说由于冲突导致重要代码被覆盖的情况。冲突发生时如果采取的措施不对可能会导致部分代码丢失，如果想要还原之前的代码也很容易。 选择文件-&gt;右键选择show log在这里面你可以看见之前提交的所有版本，找到你想要恢复的版本右键选择revert to this version 就可以恢复了. 4.8 SVN提交(SVN Commit)Svn的提交是将在工作空间做的修改进行提交，包括文件内容的修改，文件或目录的添加，删除，命名，移动等操作。如下图所示: 4.9 显示日志(Show log)通过此功能可以查到谁，什么时候，对那个目录下的那些文件进行了那些操作，如下图： 4.10 版本库浏览(Repo-browser)此功能是用来浏览需要查看的资料库，在本地文件夹下点击右键，选择TortoiseSVNàRepo-browser,在弹出的对话框中输入资料库地址，再输入用户名和密码，就能查看到你需要查看到版本库的内容，在这你还能看到那些文件被谁锁定了，如下图： 三：创建分支合并相互操作项目中为何要创建分支，及合并？ 比如我现在项目所有的文件放在主干上(trunk)中，由于需求的变更，需要增加新的需求，但是我们主干上还要继续往下开发，在此我们可以新建一个分支，来做增加新的需求那一块，主干上继续开发，等分支上代码没有问题的时候，再合并到主干上来。 创建分支的最大的目的就是跟主线进行并行开发时候不影响主线的开发。 如何操作？ 假如我本地新建一个文件夹test下有2个文件夹trunk(存放主干上的代码)和branch(存放分支上的代码)，如下所示： 先提取主干上的代码。 点击trunk –&gt; 鼠标右键 –&gt; 点击SVN Checkout –&gt; 弹出一个对话框，如下图所示： 其中上面的URL是从服务器VisualSVN Server上获取的，如下所示： 直接右键qianduan3 –&gt; Copy URL to Clipboard 即可。 其中qianduan3项目有如下文件，如下图所示： 最后点击上面的checkout按钮后，就可以在主干上把代码从远程服务器上获取到，如下所示： 新建分支 从trunk（主干上）创建分支(branch)步骤如下： 右键trunk –&gt; branch/Tag 如下图： 在弹出的对话框如下图： 点击ok按钮后，就可以在VisualSVN Serval服务器上新增newBranch，是从如上服务器qianduan3上的文件拷贝一份的，如下所示： 现在我们可以再来看看本地branch文件夹了，我现在直接进入branch文件下，右键 –&gt; Chenckout下，就可以把newBranch下的所有文件提取出来了，如下所示： 点击ok按钮就可以把文件提取出来了，如下图所示： 分支目前建立在svn的服务器端，本地并没有更新，对本地branch文件夹 右键–&gt; update即可，就可以更新到分支代码，如下所示： 合并分支到主干上 比如我现在对branch分支上新增3.txt文件，然后提交上去，如下所示： 我现在想把分支上的代码3.txt合并到主干上trunk，现在要怎么合并呢？步骤如下： 回到我们刚刚的主干（trunk）文件夹下，鼠标右键该文件夹 –&gt; TortoiseSVN –&gt; Merge 如下图所示：52.jpg 在弹出的窗口，如下图所示： 接着点击【Next】下一步，如下图所示： 再接着【Next】下一步，如下图所示： 就可以看到主干trunk上多加了一个3.txt，就是从分支上合并过来的。 合并主干到分支。 如果主干上有一些更新，比如说jar包更新等等，那么这些要更新到分支上去，如何操作呢？比如我现在在主干上新建一个4.txt文件，比如如下： 我现在的分支上目录如下： 现在是想把主干上的4.txt合并到分支上来，要如何操作？步骤如下，还是和刚刚操作类似. 我们在分支点击branch –&gt; 右键TortoiseSVN –&gt; Merge 如下图所示： 在弹出新窗口后，如下图所示： 接着点击【Next】下一步，如下图所示： 继续下一步，如下图： 最后直接merge，就可以看到分支branch上也有主干上的4.txt文件了，也就是说，合并主干到分支上也是可以的，如下图所示：","categories":[],"tags":[{"name":"svn教程","slug":"svn教程","permalink":"http://yoursite.com/tags/svn教程/"}]},{"title":"商城项目00","slug":"商城项目00","date":"2017-07-30T07:24:54.000Z","updated":"2017-07-30T07:25:45.505Z","comments":true,"path":"2017/07/30/商城项目00/","link":"","permalink":"http://yoursite.com/2017/07/30/商城项目00/","excerpt":"","text":"项目安排","categories":[],"tags":[{"name":"商城项目","slug":"商城项目","permalink":"http://yoursite.com/tags/商城项目/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"商城项目01","slug":"商城项目01","date":"2017-07-30T07:19:47.000Z","updated":"2017-07-30T07:53:12.011Z","comments":true,"path":"2017/07/30/商城项目01/","link":"","permalink":"http://yoursite.com/2017/07/30/商城项目01/","excerpt":"电商项目背景电商行业技术特点 技术新 技术范围广 分布式 高并发、集群、负载均衡、高可用 海量数据 业务复杂 系统安全","text":"电商项目背景电商行业技术特点 技术新 技术范围广 分布式 高并发、集群、负载均衡、高可用 海量数据 业务复杂 系统安全 商城项目简介商城是一个综合性的B2C平台，类似京东商城、天猫商城。会员可以在商城浏览商品、下订单，以及参加各种活动。管理员、运营可以在平台后台管理系统中管理商品、订单、会员等。客服可以在后台管理系统中处理用户的询问以及投诉。 电商模式：B2B：商家到商家。阿里巴巴，慧聪网、铭万网。B2C：商家到用户。京东。C2C：用户到用户。淘宝。B2B2C：商家到商家到用户。天猫。O2O：线上到线下。百度外卖、美团、饿了么。 项目架构功能列表后台管理系统：管理商品、订单、类目、商品规格属性、用户管理以及内容发布等功能。前台系统：用户可以在前台系统中进行注册、登录、浏览商品、首页、下单等操作。会员系统：用户可以在该系统中查询已下的订单、收藏的商品、我的优惠券、团购等信息。订单系统：提供下单、查询订单、修改订单状态、定时处理订单。搜索系统：提供商品的搜索功能。单点登录系统：为多个系统之间提供用户登录凭证以及查询登录用户的信息 系统架构传统架构 1000并发对于传统架构进行开发，假设每台tomcat服务器的最大并发访问量是500，那么1000并发就需要2台服务器做tomcat集群。 10000并发 需要20台服务器做tomcat集群。当tomcat集群中节点数量增加，服务能力先增加后下降。所以集群中节点数量不能太多，一般也就5个左右。 需要按照功能点把系统拆分，拆分成独立的功能。单独为某一个节点添加服务器。需要系统之间配合才能完成整个业务逻辑。叫做分布式。 分布式架构：多个子系统相互协作才能完成业务流程。系统之间需要进行通信。集群：同一个工程部署到多台服务器上。分布式架构：把系统按照模块拆分成多个子系统。优点：1、把模块拆分，使用接口通信，降低模块之间的耦合度。2、把项目拆分成若干个子项目，不同的团队负责不同的子项目。3、增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。4、可以灵活的进行分布式部署。 缺点：1、系统之间交互需要使用远程通信，接口开发增加工作量。2、各个模块有一些通用的业务逻辑无法共用。 soa架构SOA：Service Oriented Architecture面向服务的架构。也就是把工程拆分成服务层、表现层两个工程。服务层中包含业务逻辑和持久层，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。 商城架构商城的架构是基于soa架构，表现层就是该项目的各个功能模块，把业务逻辑放在单独的服务层，当然，该层还包含了DAO的的相关处理。其中dubbo是alibaba的一个中间件，类似于webservice，因为表现层和服务层已经分开，所以当需要调用相关业务的时候，需要我们进行相关协议的调用。当用户的并发搜索量很大的时候，可以使用Redis进行全文检索。 工程搭建——maven工程","categories":[],"tags":[{"name":"商城项目","slug":"商城项目","permalink":"http://yoursite.com/tags/商城项目/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"啊哈算法-排序算法","slug":"啊哈算法-排序算法","date":"2017-07-29T14:04:51.000Z","updated":"2017-07-29T15:21:40.530Z","comments":true,"path":"2017/07/29/啊哈算法-排序算法/","link":"","permalink":"http://yoursite.com/2017/07/29/啊哈算法-排序算法/","excerpt":"1. 桶排序 期末考试完了老师要将同学们的分数按照从高到低排序。小哼的班上只有 5个同学，这 5个同学分别考了 5分、3分、5分、2分和 8分，哎考得真是惨不忍睹（满分是 10分）。接下来将分数进行从大到小排序，排序后是 8 5 5 3 2。你有没有什么好方法编写一段程序，让计算机随机读入 5个数然后将这5个数从大到小输出？请先想一想，至少想 15分钟再往下看吧(^__^)。","text":"1. 桶排序 期末考试完了老师要将同学们的分数按照从高到低排序。小哼的班上只有 5个同学，这 5个同学分别考了 5分、3分、5分、2分和 8分，哎考得真是惨不忍睹（满分是 10分）。接下来将分数进行从大到小排序，排序后是 8 5 5 3 2。你有没有什么好方法编写一段程序，让计算机随机读入 5个数然后将这5个数从大到小输出？请先想一想，至少想 15分钟再往下看吧(^__^)。我们这里只需借助一个一维数组就可以解决这个问题。 首先我们需要申请一个大小为 11的数组 int a[11]。OK，现在你已经有了 11个变量，编号从 a[0]~a[10]。刚开始的时候，我们将 a[0]~a[10]都初始化为 0，表示这些分数还都没有人得过。例如 a[0]等于 0就表示目前还没有人得过 0分，同理 a[1]等于 0就表示目前还没有人得过 1分……a[10]等于 0就表示目前还没有人得过 10分。下面开始处理每一个人的分数，第一个人的分数是 5分，我们就将相对应的 a[5]的值在原来的基础增加 1，即将 a[5]的值从 0改为 1，表示 5分出现过了一次。第二个人的分数是 3分，我们就把相对应的 a[3]的值在原来的基础上增加 1，即将 a[3]的值从 0改为 1，表示 3分出现过了一次。注意啦！第三个人的分数也是 5分，所以 a[5]的值需要在此基础上再增加 1，即将 a[5]的值从 1改为 2，表示 5分出现过了两次。按照刚才的方法处理第四个和第五个人的分数。最终结果就是下面这个图啦。你发现没有，a[0]~a[10]中的数值其实就是 0分到 10分每个分数出现的次数。接下来，我们只需要将出现过的分数打印出来就可以了，出现几次就打印几次，具体如下。a[0]为 0，表示“0”没有出现过，不打印。a[1]为 0，表示“1”没有出现过，不打印。a[2]为 1，表示“2”出现过 1次，打印 2。a[3]为 1，表示“3”出现过 1次，打印 3。a[4]为 0，表示“4”没有出现过，不打印。a[5]为 2，表示“5”出现过 2次，打印 5 5。a[6]为 0，表示“6”没有出现过，不打印。a[7]为 0，表示“7”没有出现过，不打印。a[8]为 1，表示“8”出现过 1次，打印 8。a[9]为 0，表示“9”没有出现过，不打印。a[10]为 0，表示“10”没有出现过，不打印。最终屏幕输出“2 3 5 5 8”，完整的代码如下。代码如下（C++）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;int main()&#123;int a[11],i,j,t;for(i=0;i&lt;=10;i++)a[i]=0; //初始化为0for(i=1;i&lt;=5;i++) //循环读入5个数&#123;scanf(\"%d\",&amp;t); //把每一个数读到变量t中a[t]++; //进行计数&#125;for(i=0;i&lt;=10;i++) //依次判断a[0]~a[10]for(j=1;j&lt;=a[i];j++) //出现了几次就打印几次printf(\"%d \",i);getchar();getchar();//这里的getchar();用来暂停程序，以便查看程序输出的内容//也可以用system(\"pause\");等来代替return 0;&#125; ``` 输入数据为： `5 3 5 2 8 ` 这种排序方法我们暂且叫它“桶排序”。因为其实真正的桶排序要比这个复杂一些，以后再详细讨论，目前此算法已经能够满足我们的需求了。 这个算法就好比有 11个桶，编号从 0~10。每出现一个数，就在对应编号的桶中放一个小旗子，最后只要数数每个桶中有几个小旗子就 OK了。例如 2号桶中有 1个小旗子，表示2出现了一次；3号桶中有 1个小旗子，表示 3出现了一次；5号桶中有 2个小旗子，表示 5出现了两次；8号桶中有 1个小旗子，表示 8出现了一次。 ![问题](啊哈算法-排序算法/7.jpg) 如果需要对数据范围在 0~1000之间的整数进行排序，我们需要 1001个桶，来表示 0~1000之间每一个数出现的次数，这一点一定要注意。另外，此处的每一个桶的作用其实就是“标记”每个数出现的次数，因此我喜欢将之前的数组 a换个更贴切的名字 book（book这个单词有记录、标记的意思），代码实现如下。 ``` c++#include &lt;stdio.h&gt;int main()&#123;int book[1001],i,j,t,n;for(i=0;i&lt;=1000;i++)book[i]=0;scanf(\"%d\",&amp;n);//输入一个数n，表示接下来有n个数for(i=1;i&lt;=n;i++)//循环读入n个数，并进行桶排序&#123;scanf(\"%d\",&amp;t); //把每一个数读到变量t中book[t]++; //进行计数，对编号为t的桶放一个小旗子&#125;for(i=1000;i&gt;=0;i--) //依次判断编号1000~0的桶for(j=1;j&lt;=book[i];j++) //出现了几次就将桶的编号打印几次printf(\"%d \",i);getchar();getchar();return 0;&#125; 可以输入以下数据进行验证。 108 100 50 22 15 6 1 1000 999 0 运行结果是： 1000 999 100 50 22 15 8 6 1 0 时间复杂度代码中第 一次for循环一共循环了 m次（m为桶的个数），第 9行的代码循环了 n次（n为待排序数的个数），第 二次和第三次for一共循环了 m+n次。所以整个排序算法一共执行了 m+n+m+n次。我们用大写字母 O来表示时间复杂度，因此该算法的时间复杂度是 O(m+n+m+n)即 O(2*(m+n))。我们在说时间复杂度的时候可以忽略较小的常数，最终桶排序的时间复杂度为 O(m+n)。还有一点，在表示时间复杂度的时候，n和 m通常用大写字母即 O(M+N)。这是一个非常快的排序算法。桶排序从 1956年就开始被使用，该算法的基本思想是由E.J.Issac和 R.C.Singleton提出来的。之前我说过，其实这并不是真正的桶排序算法，真正的桶排序算法要比这个更加复杂。但是考虑到此处是算法讲解的第一篇，我想还是越简单易懂越好，真正的桶排序留在以后再聊吧。需要说明一点的是：我们目前学习的简化版桶排序算法，其本质上还不能算是一个真正意义上的排序算法。为什么呢？例如遇到下面这个例子就没辙了。现在分别有 5个人的名字和分数：huhu 5分、haha 3分、xixi 5分、hengheng 2分和 gaoshou8分。请按照分数从高到低，输出他们的名字。即应该输出 gaoshou、huhu、xixi、haha、hengheng。发现问题了没有？如果使用我们刚才简化版的桶排序算法仅仅是把分数进行了排序。最终输出的也仅仅是分数，但没有对人本身进行排序。也就是说，我们现在并不知道排序后的分数原本对应着哪一个人！这该怎么办呢？不要着急，请看下节——冒泡排序。 2. 邻居好说话——冒泡排序简化版的桶排序不仅仅有上一节所遗留的问题，更要命的是：它非常浪费空间！例如需要排序数的范围是 0~2100000000之间，那你则需要申请 2100000001个变量，也就是说要写成 int a[2100000001]。因为我们需要用 2100000001个“桶”来存储 0~2100000000之间每一个数出现的次数。即便只给你 5个数进行排序（例如这 5个数是 1、1912345678、2100000000、18000000和 912345678），你也仍然需要 2100000001个“桶”，这真是太浪费空间了！还有，如果现在需要排序的不再是整数而是一些小数，比如将 5.56789、2.12、1.1、3.123、4.1234这五个数进行从小到大排序又该怎么办呢？现在我们来学习另一种新的排序算法：冒泡排序。它可以很好地解决这两个问题。 冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。 例如我们需要将 12 35 99 18 76这 5个数进行从大到小的排序。既然是从大到小排序，也就是说越小的越靠后，你是不是觉得我在说废话，但是这句话很关键(∩_∩)。 首先比较第 1位和第 2位的大小，现在第 1位是 12，第 2位是 35。发现 12比 35要小，因为我们希望越小越靠后嘛，因此需要交换这两个数的位置。交换之后这 5个数的顺序是35 12 99 18 76。 按照刚才的方法，继续比较第 2位和第 3位的大小，第 2位是 12，第 3位是 99。12比99要小，因此需要交换这两个数的位置。交换之后这 5个数的顺序是 35 99 12 18 76。 根据刚才的规则，继续比较第 3位和第 4位的大小，如果第 3位比第 4位小，则交换位置。交换之后这 5个数的顺序是 35 99 18 12 76。 最后，比较第 4位和第 5位。4次比较之后 5个数的顺序是 35 99 18 76 12。 经过 4次比较后我们发现最小的一个数已经就位（已经在最后一位，请注意 12这个数的移动过程），是不是很神奇。现在再来回忆一下刚才比较的过程。每次都是比较相邻的两个数，如果后面的数比前面的数大，则交换这两个数的位置。一直比较下去直到最后两个数比较完毕后，最小的数就在最后一个了。就如同是一个气泡，一步一步往后“翻滚”，直到最后一位。所以这个排序的方法有一个很好听的名字“冒泡排序”。 说到这里其实我们的排序只将 5个数中最小的一个归位了。每将一个数归位我们将其称为“一趟”。下面我们将继续重复刚才的过程，将剩下的 4个数一一归位。 好，现在开始“第二趟”，目标是将第 2小的数归位。首先还是先比较第 1位和第 2位，如果第 1位比第 2位小，则交换位置。交换之后这 5个数的顺序是 99 35 18 76 12。接下来你应该都会了，依次比较第 2位和第 3位，第 3位和第 4位。注意此时已经不需要再比较第 4位和第 5位。因为在第一趟结束后已经可以确定第 5位上放的是最小的了。第二趟结束之后这 5个数的顺序是 99 35 76 18 12。 “第三趟”也是一样的。 第三趟之后这 5个数的顺序是 99 76 35 18 12。 现在到了最后一趟“第四趟”。有的同学又要问了，这不是已经排好了吗？还要继续？ 当然，这里纯属巧合，你若用别的数试一试可能就不是了。你能找出这样的数据样例来吗？请试一试。 “冒泡排序”的原理是：每一趟只能确定将一个数归位。即第一趟只能确定将末位上的数（即第 5位）归位，第二趟只能将倒数第 2位上的数（即第 4位）归位，第三趟只能将倒数第 3位上的数（即第 3位）归位，而现在前面还有两个位置上的数没有归位，因此我们仍然需要进行“第四趟”。“第四趟”只需要比较第 1位和第 2位的大小。因为后面三个位置上的数归位了，现在第 1位是 99，第 2位是 76，无需交换。这 5个数的顺序不变仍然是 99 76 35 18 12。到此排序完美结束了，5个数已经有 4个数归位，那最后一个数也只能放在第 1位了。 最后我们总结一下：如果有 n个数进行排序，只需将 n1个数归位，也就是说要进行n-1趟操作。而“每一趟”都需要从第 1位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一个尚未归位的数，已经归位的数则无需再进行比较（已经归位的数你还比较个啥，浪费表情）。 这个算法是不是很强悍？记得我每次拍集体照的时候就总是被别人换来换去的，当时特别烦。不知道发明此算法的人当时的灵感是否来源于此。啰里吧嗦地说了这么多，下面是代码。建议先自己尝试去实现一下看看，再来看我是如何实现的。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123;int a[100],i,j,t,n;scanf(\"%d\",&amp;n); //输入一个数n，表示接下来有n个数for(i=1;i&lt;=n;i++) //循环读入n个数到数组a中scanf(\"%d\",&amp;a[i]);//冒泡排序的核心部分for(i=1;i&lt;=n-1;i++) //n个数排序，只用进行n-1趟&#123;for(j=1;j&lt;=n-i;j++) //从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了。&#123;if(a[j]&lt;a[j+1]) //比较大小并交换&#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125;&#125;&#125;for(i=1;i&lt;=n;i++) //输出结果printf(\"%d \",a[i]);getchar();getchar();return 0;&#125; 可以输入以下数据进行验证。10 8 100 50 22 15 6 1 1000 999 0运行结果是： 0 1 6 8 15 22 50 100 999 1000 将上面代码稍加修改，就可以解决第 1节遗留的问题，如下。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;struct student&#123;char name[21];char score;&#125;;//这里创建了一个结构体用来存储姓名和分数int main()&#123;struct student a[100],t;int i,j,n;scanf(\"%d\",&amp;n); //输入一个数nfor(i=1;i&lt;=n;i++) //循环读入n个人名和分数scanf(\"%s %d\",a[i].name,&amp;a[i].score);//按分数从高到低进行排序for(i=1;i&lt;=n-1;i++)&#123;for(j=1;j&lt;=n-i;j++)&#123;if(a[j].score&lt;a[j+1].score)//对分数进行比较&#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125;&#125;&#125;for(i=1;i&lt;=n;i++)//输出人名printf(\"%s\\n\",a[i].name);getchar();getchar();return 0;&#125; 可以输入以下数据进行验证。5 huhu 5 haha 3 xixi 5 hengheng 2 gaoshou 8 运行结果是：gaoshou huhu xixi haha hengheng 冒泡排序的核心部分是双重嵌套循环。不难看出冒泡排序的时间复杂度是 O(N 2)。这是一个非常高的时间复杂度。冒泡排序早在 1956年就有人开始研究，之后有很多人都尝试过对冒泡排序进行改进，但结果却令人失望。如 Donald E. Knuth（中文名为高德纳，1974年图灵奖获得者）所说：“冒泡排序除了它迷人的名字和导致了某些有趣的理论问题这一事实之外，似乎没有什么值得推荐的。”你可能要问：那还有没有更好的排序算法呢？不要走开，请看下节——快速排序。 3. 最常用的排序——快速排序上一节的冒泡排序可以说是我们学习的第一个真正的排序算法，并且解决了桶排序浪费空间的问题，但在算法的执行效率上却牺牲了很多，它的时间复杂度达到了 O(N2)。假如我们的计算机每秒钟可以运行 10亿次，那么对 1亿个数进行排序，桶排序只需要 0.1秒，而冒泡排序则需要 1千万秒，达到 115天之久，是不是很吓人？那有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢？ 假设我们现在对“6 1 2 7 9 3 4 5 10 8”这 10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，这就是一个用来参照的数，待会儿你就知道它用来做啥了）。为了方便，就让第一个数 6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 6的右边，比基准数小的数放在 6的左边，类似下面这种排列。 3 1 2 5 4 6 9 7 10 8 在初始状态下，数字 6在序列的第 1位。我们的目标是将 6挪到序列中间的某个位置，假设这个位置是 k。现在就需要寻找这个 k，并且以第 k位为分界点，左边的数都小于等于 6，右边的数都大于等于 6。想一想，你有办法可以做到这点吗？ 给你一个提示吧。请回忆一下冒泡排序是如何通过“交换”一步步让每个数归位的。此时你也可以通过“交换”的方法来达到目的。具体是如何一步步交换呢？怎样交换才既方便又节省时间呢？先别急着往下看，拿出笔来，在纸上画画看。我高中时第一次学习冒泡排序算法的时候，就觉得冒泡排序很浪费时间，每次都只能对相邻的两个数进行比较，这显然太不合理了。于是我就想了一个办法，后来才知道原来这就是“快速排序”，请允许我小小地自恋一下(^o^)。 方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于 6的数，再从左往右找一个大于 6的数，然后交换它们。这里可以用两个变量 i和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i指向序列的最左边（即 i=1），指向数字 6。让哨兵 j指向序列的最右边（即 j=10），指向数字 8。 首先哨兵 j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j先出动，这一点非常重要（请自己想一想为什么）。哨兵 j一步一步地向左挪动（即 j），直到找到一个小于 6的数停下来。接下来哨兵 i再一步一步向右挪动（即 i++），直到找到一个大于 6的数停下来。最后哨兵 j停在了数字 5面前，哨兵 i停在了数字 7面前。 现在交换哨兵 i和哨兵 j所指向的元素的值。交换之后的序列如下。 6 1 2 5 9 3 4 7 10 8 到此，第一次交换结束。接下来哨兵 j继续向左挪动（再次友情提醒，每次必须是哨兵j先出发）。他发现了 4（比基准数 6要小，满足要求）之后停了下来。哨兵 i也继续向右挪动，他发现了 9（比基准数 6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。 6 1 2 5 4 3 9 7 10 8 第二次交换结束，“探测”继续。哨兵 j继续向左挪动，他发现了 3（比基准数 6要小，满足要求）之后又停了下来。哨兵 i继续向右移动，糟啦！此时哨兵 i和哨兵 j相遇了，哨兵 i和哨兵 j都走到 3面前。说明此时“探测”结束。我们将基准数 6和 3进行交换。交换之后的序列如下。 3 1 2 5 4 6 9 7 10 8 到此第一轮“探测”真正结束。此时以基准数 6为分界点，6左边的数都小于等于 6，6右边的数都大于等于 6。回顾一下刚才的过程，其实哨兵 j的使命就是要找小于基准数的数，而哨兵 i的使命就是要找大于基准数的数，直到 i和 j碰头为止。 OK，解释完毕。现在基准数 6已经归位，它正好处在序列的第 6位。此时我们已经将原来的序列，以 6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列，因为 6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6左边和右边的序列即可。现在先来处理 6左边的序列吧。 左边的序列是“3 1 2 5 4”。请将这个序列以 3为基准数进行调整，使得 3左边的数都小于等于 3，3右边的数都大于等于 3。好了开始动笔吧。 不用找纸了，别以为我不知道你的小伎俩，你肯定又没有动手尝试！就准备继续往下看了吧。这里我留了一个空白区域，赶快自己动手模拟一下吧！ 如果你模拟得没有错，调整完毕之后的序列的顺序应该是： 2 1 3 5 4 OK，现在 3已经归位。接下来需要处理 3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以 2为基准数进行调整，处理完毕之后的序列为“1 2”，到此 2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“ 2 1”已全部处理完毕，得到的序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下。 1 2 3 4 5 6 9 7 10 8 对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列： 1 2 3 4 5 6 7 8 9 10 到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。 快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的，都是 O(N2)，它的平均时间复杂度为 O (NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int a[101],n;//定义全局变量，这两个变量需要在子函数中使用void quicksort(int left,int right)&#123;int i,j,t,temp;if(left&gt;right)return;temp=a[left]; //temp中存的就是基准数i=left;j=right;while(i!=j)&#123;//顺序很重要，要先从右往左找while(a[j]&gt;=temp &amp;&amp; i&lt;j)j--;//再从左往右找while(a[i]&lt;=temp &amp;&amp; i&lt;j)i++;//交换两个数在数组中的位置if(i&lt;j)//当哨兵i和哨兵j没有相遇时&#123;t=a[i];a[i]=a[j];a[j]=t;&#125;&#125;//最终将基准数归位a[left]=a[i];a[i]=temp;quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程&#125;int main()&#123;int i,j,t;//读入数据scanf(\"%d\",&amp;n);for(i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]);quicksort(1,n); //快速排序调用//输出排序后的结果for(i=1;i&lt;=n;i++)printf(\"%d \",a[i]);getchar();getchar();return 0;&#125; 可以输入以下数据进行验证。 10 6 1 2 7 9 3 4 5 10 8 运行结果是： 1 2 3 4 5 6 7 8 9 10 下面是程序执行过程中数组 a的变化过程，带下划线的数表示的是已归位的基准数。 12345678910116 1 2 7 9 3 4 5 10 83 1 2 5 4 6 9 7 10 82 1 3 5 4 6 9 7 10 81 2 3 5 4 6 9 7 10 81 2 3 5 4 6 9 7 10 81 2 3 4 5 6 9 7 10 81 2 3 4 5 6 9 7 10 81 2 3 4 5 6 8 7 9 101 2 3 4 5 6 7 8 9 101 2 3 4 5 6 7 8 9 101 2 3 4 5 6 7 8 9 10 快速排序由 C. A. R. Hoare（东尼•霍尔，Charles Antony Richard Hoare）在 1960年提出，之后又有许多人做了进一步的优化。如果你对快速排序感兴趣，可以去看看东尼•霍尔1962年在 Computer Journal发表的论文“Quicksort”以及《算法导论》的第七章。快速排序算法仅仅是东尼•霍尔在计算机领域才能的第一次显露，后来他受到了老板的赏识和重用，公司希望他为新机器设计一种新的高级语言。你要知道当时还没有 PASCAL或者 C语言这些高级的东东。后来东尼•霍尔参加了由 Edsger Wybe Dijkstra（1972年图灵奖得主，这个大神我们后面还会遇到的，到时候再细聊）举办的 ALGOL 60培训班，他觉得自己与其没有把握地去设计一种新的语言，还不如对现有的 ALGOL 60进行改进，使之能在公司的新机器上使用。于是他便设计了 ALGOL 60的一个子集版本。这个版本在执行效率和可靠性上都在当时 ALGOL 60的各种版本中首屈一指，因此东尼•霍尔受到了国际学术界的重视。后来他在 ALGOL X的设计中还发明了大家熟知的 case语句，也被各种高级语言广泛采用，比如PASCAL、C、Java语言等等。当然，东尼•霍尔在计算机领域的贡献还有很多很多，他在1980年获得了图灵奖。","categories":[],"tags":[{"name":"啊哈算法","slug":"啊哈算法","permalink":"http://yoursite.com/tags/啊哈算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"JSON学习","slug":"JSON学习","date":"2017-07-28T13:52:30.000Z","updated":"2017-07-28T14:37:50.305Z","comments":true,"path":"2017/07/28/JSON学习/","link":"","permalink":"http://yoursite.com/2017/07/28/JSON学习/","excerpt":"1. JSONJSON: JavaScript Object Notation(JavaScript 对象表示法)JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。","text":"1. JSONJSON: JavaScript Object Notation(JavaScript 对象表示法)JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。 JSON 实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123;\"sites\": [&#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125;, &#123; \"name\":\"google\" , \"url\":\"www.google.com\" &#125;, &#123; \"name\":\"微博\" , \"url\":\"www.weibo.com\" &#125;]&#125;``` 这个 sites 对象是包含 3 个站点记录（对象）的数组。----------## 什么是 JSON ？- JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）- JSON 是轻量级的文本数据交换格式- JSON 独立于语言 *- JSON 具有自我描述性，更易理解 * JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。## JSON - 转换为 JavaScript 对象JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。 由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。# 2. JSON简介## 2.1 实例通过我们的编辑器，您可以在线编辑 JavaScript 代码，然后通过点击一个按钮来查看结果： ``` html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;JavaScript 创建 JSON 对象&lt;/h2&gt;&lt;p&gt;网站名称: &lt;span id=\"jname\"&gt;&lt;/span&gt;&lt;br /&gt; 网站地址: &lt;span id=\"jurl\"&gt;&lt;/span&gt;&lt;br /&gt; 网站 slogan: &lt;span id=\"jslogan\"&gt;&lt;/span&gt;&lt;br /&gt; &lt;/p&gt;&lt;script&gt;var JSONObject= &#123; \"name\":\"菜鸟教程\", \"url\":\"www.runoob.com\", \"slogan\":\"学的不仅是技术，更是梦想！\"&#125;;document.getElementById(\"jname\").innerHTML=JSONObject.name document.getElementById(\"jurl\").innerHTML=JSONObject.url document.getElementById(\"jslogan\").innerHTML=JSONObject.slogan&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.2 与 XML 相同之处 JSON 是纯文本 JSON 具有”自我描述性”（人类可读） JSON 具有层级结构（值中存在值） JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输 2.3 与 XML 不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字 2.4 为什么使用 JSON？对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用：使用 XML 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 用 eval() 处理 JSON 字符串 3. JSON 语法JSON 语法是 JavaScript 语法的子集。 3.1 JSON 语法规则JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 3.2 JSON 名称/值对JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：1234567891011121314151617181920\"name\":\"菜鸟教程\"``` 这很容易理解，等价于这条 JavaScript 语句： name = \"菜鸟教程\"## 3.3 JSON 值JSON 值可以是： - 数字（整数或浮点数）- 字符串（在双引号中）- 逻辑值（true 或 false）- 数组（在中括号中）- 对象（在大括号中）- null## 3.4 JSON 数字JSON 数字可以是整型或者浮点型： ``` html&#123; \"age\":30 &#125; 3.5 JSON对象JSON 对象在大括号（{}）中书写：对象可以包含多个名称/值对：1&#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125; 这一点也容易理解，与这条 JavaScript 语句等价：12name = \"菜鸟教程\" url = \"www.runoob.com\" 3.6 JSON 数组JSON 数组在中括号中书写：数组可包含多个对象：1234567&#123;\"sites\": [&#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125;, &#123; \"name\":\"google\" , \"url\":\"www.google.com\" &#125;, &#123; \"name\":\"微博\" , \"url\":\"www.weibo.com\" &#125;]&#125; 在上面的例子中，对象 “sites” 是包含三个对象的数组。每个对象代表一条关于某个网站（name、url）的记录。 3.7 JSON 布尔值JSON 布尔值可以是 true 或者 false：1&#123; \"flag\":true &#125; 3.8 JSON nullJSON 可以设置 null 值：1&#123; \"runoob\":null &#125; 3.9 JSON 使用 JavaScript 语法因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值：实例12345var sites = [ &#123; \"name\":\"runoob\" , \"url\":\"www.runoob.com\" &#125;, &#123; \"name\":\"google\" , \"url\":\"www.google.com\" &#125;, &#123; \"name\":\"微博\" , \"url\":\"www.weibo.com\" &#125;]; 可以像这样访问 JavaScript 对象数组中的第一项（索引从 0 开始）：sites[0].name;返回的内容是：runoob可以像这样修改数据：sites[0].name=”菜鸟教程”; 3.10 JSON 文件JSON 文件的文件类型是 “.json”JSON 文本的 MIME 类型是 “application/json” 4. JSON 对象4.1 对象语法实例1&#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125; JSON 对象使用在大括号({})中书写。对象可以包含多个 key/value（键/值）对。key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。key 和 value 中使用冒号(:)分割。每个 key/value 对使用逗号(,)分割。 4.2 访问对象值你可以使用点号（.）来访问对象的值：实例123var myObj, x; myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125;;x = myObj.name; 你也可以使用中括号（[]）来访问对象的值：实例123var myObj, x;myObj = myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125;;x = myObj[\"name\"]; 4.3 循环对象你可以使用 for-in 来循环对象的属性：实例1234var myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125;;for (x in myObj) &#123; document.getElementById(\"demo\").innerHTML += x + \"&lt;br&gt;\";&#125; 在 for-in 循环对象的属性时，使用中括号（[]）来访问属性的值：实例1234var myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125;;for (x in myObj) &#123; document.getElementById(\"demo\").innerHTML += myObj[x] + \"&lt;br&gt;\";&#125; 4.4 嵌套 JSON 对象JSON 对象中可以包含另外一个 JSON 对象：实例12345678910111213141516myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"sites\": &#123; \"site1\":\"www.runoob.com\", \"site2\":\"m.runoob.com\", \"site3\":\"c.runoob.com\" &#125;&#125;``` 你可以使用点号(.)或者中括号([])来访问嵌套的 JSON 对象。 实例 ``` javax = myObj.sites.site1;// 或者x = myObj.sites[\"site1\"]; 4.5 修改值你可以使用点号(.)来修改 JSON 对象的值：实例 myObj.sites.site1 = &quot;www.google.com&quot;; 你可以使用中括号([])来修改 JSON 对象的值：实例myObj.sites[&quot;site1&quot;] = &quot;www.google.com&quot;; 4.6 删除对象属性我们可以使用 delete 关键字来删除 JSON 对象的属性：实例 delete myObj.sites.site1; 你可以使用中括号([])来删除 JSON 对象的属性：实例delete myObj.sites[&quot;site1&quot;] 5. JSON 数组5.1 数组作为 JSON 对象实例[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ]JSON 数组在中括号中书写。JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。JavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 undefined。 5.2 JSON 对象中的数组对象属性的值可以是一个数组：实例12345&#123;\"name\":\"网站\",\"num\":3,\"sites\":[ \"Google\", \"Runoob\", \"Taobao\" ]&#125; 我们可以使用索引值来访问数组：实例x = myObj.sites[0]; 5.3 循环数组你可以使用 for-in 来访问数组：实例123for (i in myObj.sites) &#123; x += myObj.sites[i] + \"&lt;br&gt;\";&#125; 你也可以使用 for 循环：实例12for (i = 0; i &lt; myObj.sites.length; i++) &#123; x += myObj.sites[i] + \"&lt;br&gt;\"; 5.4 嵌套 JSON 对象中的数组JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象：实例123456789myObj = &#123; \"name\":\"网站\", \"num\":3, \"sites\": [ &#123; \"name\":\"Google\", \"info\":[ \"Android\", \"Google 搜索\", \"Google 翻译\" ] &#125;, &#123; \"name\":\"Runoob\", \"info\":[ \"菜鸟教程\", \"菜鸟工具\", \"菜鸟微信\" ] &#125;, &#123; \"name\":\"Taobao\", \"info\":[ \"淘宝\", \"网购\" ] &#125; ]&#125; 我们可以使用 for-in 来循环访问每个数组：实例123456for (i in myObj.sites) &#123; x += \"&lt;h1&gt;\" + myObj.sites[i].name + \"&lt;/h1&gt;\"; for (j in myObj.sites[i].info) &#123; x += myObj.sites[i].info[j] + \"&lt;br&gt;\"; &#125;&#125; 5.5 修改数组值你可以使用索引值来修改数组值：实例myObj.sites[1] = &quot;Github&quot;; 5.6 删除数组元素我们可以使用 delete 关键字来删除数组元素：实例delete myObj.sites[1]; 6. JSON.parse()JSON 通常用于与服务端交换数据。在接收服务器数据时一般是字符串。我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。语法JSON.parse(text[, reviver])参数说明：text:必需， 一个有效的 JSON 字符串。reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。 6.1 JSON 解析实例例如我们从服务器接收了以下数据：{ &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; }我们使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象：var obj = JSON.parse(&#39;{ &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; }&#39;);解析前要确保你的数据是标准的 JSON 格式，否则会解析出错。你可以使用我们的在线工具检测：https://c.runoob.com/front-end/53。解析完成后，我们就可以在网页上使用 JSON 数据了：实例123456&lt;p id=\"demo\"&gt;&lt;/p&gt; &lt;script&gt;var obj = JSON.parse('&#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" &#125;');document.getElementById(\"demo\").innerHTML = obj.name + \"：\" + obj.site;&lt;/script&gt; 6.2 从服务端接收 JSON 数据我们可以使用 AJAX 从服务器请求 JSON 数据，并解析为 JavaScript 对象。实例1234567891011121314151617181920212223var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myObj = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myObj.name; &#125;&#125;;xmlhttp.open(\"GET\", \"/try/ajax/json_demo.txt\", true);xmlhttp.send();``` ## 6.3 从服务端接收数组的 JSON 数据如果从服务端接收的是数组的 JSON 数据，则 JSON.parse 会将其转换为 JavaScript 数组： 实例 ``` htmlvar xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myArr = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myArr[1]; &#125;&#125;;xmlhttp.open(\"GET\", \"/try/ajax/json_demo_array.txt\", true);xmlhttp.send(); 6.4 异常解析数据JSON 不能存储 Date 对象。如果你需要存储 Date 对象，需要将其转换为字符串。之后再将字符串转换为 Date 对象。实例12345var text = '&#123; \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"&#125;';var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate); document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期: \" + obj.initDate; 我们可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数。实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var text = '&#123; \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"&#125;';var obj = JSON.parse(text, function (key, value) &#123; if (key == \"initDate\") &#123; return new Date(value); &#125; else &#123; return value;&#125;&#125;); document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期：\" + obj.initDate;``` ## 6.5 解析函数JSON 不允许包含函数，但你可以将函数作为字符串存储，之后再将字符串转换为函数。 实例 ``` htmlvar text = '&#123; \"name\":\"Runoob\", \"alexa\":\"function () &#123;return 10000;&#125;\", \"site\":\"www.runoob.com\"&#125;';var obj = JSON.parse(text);obj.alexa = eval(\"(\" + obj.alexa + \")\"); document.getElementById(\"demo\").innerHTML = obj.name + \" Alexa 排名：\" + obj.alexa();``` 不建议在 JSON 中使用函数。## 6.6 浏览器支持主流浏览器都支持 JSON.parse() 函数： - Firefox 3.5- Internet Explorer 8- Chrome- Opera 10- Safari 4# 7. JSON.stringify()JSON 通常用于与服务端交换数据。 在向服务器发送数据时一般是字符串。 我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。 语法 `JSON.stringify(value[, replacer[, space]])`参数说明： - **value:** 必需， 一个有效的 JSON 字符串。 - **replacer: ** 可选。用于转换结果的函数或数组。 如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：\"\"。 如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。 - **space:** 可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 有可以使用非数字，如：\\t。 ## 7.1 JavaScript 对象转换例如我们向服务器发送以下数据： `var obj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\"&#125;;`我们使用 JSON.stringify() 方法处理以上数据，将其转换为字符串： `var myJSON = JSON.stringify(obj);`myJSON 为字符串。 我们可以将 myJSON 发送到服务器： 实例 ``` htmlvar obj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\"&#125;;var myJSON = JSON.stringify(obj);document.getElementById(\"demo\").innerHTML = myJSON;``` ## 7.2 JavaScript 数组转换我们也可以将 JavaScript 数组转换为 JSON 字符串： 实例 ``` htmlvar arr = [ \"Google\", \"Runoob\", \"Taobao\", \"Facebook\" ];var myJSON = JSON.stringify(arr); myJSON 为字符串。我们可以将 myJSON 发送到服务器：实例123456789101112131415161718192021222324var arr = [ \"Google\", \"Runoob\", \"Taobao\", \"Facebook\" ];var myJSON = JSON.stringify(arr);document.getElementById(\"demo\").innerHTML = myJSON;``` ## 7.3 异常解析数据 JSON 不能存储 Date 对象。 JSON.stringify() 会将所有日期转换为字符串。 实例 ``` htmlvar obj = &#123; \"name\":\"Runoob\", \"initDate\":new Date(), \"site\":\"www.runoob.com\"&#125;;var myJSON = JSON.stringify(obj);document.getElementById(\"demo\").innerHTML = myJSON;``` 之后你可以再将字符串转换为 Date 对象。## 7.4 解析函数JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。 实例 ``` htmlvar obj = &#123; \"name\":\"Runoob\", \"alexa\":function () &#123;return 10000;&#125;, \"site\":\"www.runoob.com\"&#125;;var myJSON = JSON.stringify(obj); document.getElementById(\"demo\").innerHTML = myJSON; 我们可以在执行 JSON.stringify() 函数前将函数转换为字符串来避免以上问题的发生：实例12345var obj = &#123; \"name\":\"Runoob\", \"alexa\":function () &#123;return 10000;&#125;, \"site\":\"www.runoob.com\"&#125;;obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); document.getElementById(\"demo\").innerHTML = myJSON; 不建议在 JSON 中使用函数。 8. JSON 使用8.1 把 JSON 文本转换为 JavaScript 对象JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。为了更简单地为您讲解，我们使用字符串作为输入进行演示（而不是文件）。 8.2 JSON 实例 - 来自字符串的对象创建包含 JSON 语法的 JavaScript 字符串：1234567var txt = '&#123; \"sites\" : [' +'&#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125;,' +'&#123; \"name\":\"google\" , \"url\":\"www.google.com\" &#125;,' +'&#123; \"name\":\"微博\" , \"url\":\"www.weibo.com\" &#125; ]&#125;';由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：var obj = eval (\"(\" + txt + \")\"); 在网页中使用 JavaScript 对象：实例123456789var txt = '&#123; \"sites\" : [' +'&#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125;,' +'&#123; \"name\":\"google\" , \"url\":\"www.google.com\" &#125;,' +'&#123; \"name\":\"微博\" , \"url\":\"www.weibo.com\" &#125; ]&#125;'; var obj = eval (\"(\" + txt + \")\"); document.getElementById(\"name\").innerHTML=obj.sites[0].name document.getElementById(\"url\").innerHTML=obj.sites[0].url 8.3 JSON 解析器lamp eval() 函数可编译并执行任何 JavaScript 代码。这隐藏了一个潜在的安全问题。使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。JSON 解析器只能识别 JSON 文本，而不会编译脚本。在浏览器中，这提供了原生的 JSON 支持，而且 JSON 解析器的速度更快。较新的浏览器和最新的 ECMAScript (JavaScript) 标准中均包含了原生的对 JSON 的支持。 9. JSONP 教程本章节我们将向大家介绍 JSONP 的知识。Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。为什么我们从不同的域（网站）访问数据需要一个特殊的技术(JSONP )呢？这是因为同源策略。同源策略，它是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。 9.1 JSONP 应用 服务端JSONP格式数据如客户想访问 : http://www.runoob.com/try/ajax/jsonp.php?jsonp=callbackFunction。假设客户期望返回JSON数据：[“customername1”,”customername2”]。真正返回到客户端的数据显示为: callbackFunction([“customername1”,”customername2”])。服务端文件jsonp.php代码为：jsonp.php 文件代码 123456789&lt;?phpheader('Content-type: application/json');//获取回调函数名$jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);//json数据$json_data = '[\"customername1\",\"customername2\"]';//输出jsonp格式的数据echo $jsoncallback . \"(\" . $json_data . \")\";?&gt; 客户端实现 callbackFunction 函数 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type=\"text/javascript\"&gt;function callbackFunction(result, methodName)&#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; result.length; i++) &#123; html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; document.getElementById('divCustomers').innerHTML = html;&#125;&lt;/script&gt;``` **页面展示 **`&lt;div id=\"divCustomers\"&gt;&lt;/div&gt;` **客户端页面完整代码**``` html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;JSONP 实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"divCustomers\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt;function callbackFunction(result, methodName) &#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; result.length; i++) &#123; html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; document.getElementById('divCustomers').innerHTML = html; &#125;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9.2 jQuery 使用 JSONP以上代码可以使用 jQuery 代码实例：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JSONP 实例&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id=\"divCustomers\"&gt;&lt;/div&gt;&lt;script&gt;$.getJSON(\"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?\", function(data) &#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; $('#divCustomers').html(html); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSON格式化工具","categories":[],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"HTTP协议","slug":"HTTP协议","date":"2017-07-27T13:56:56.000Z","updated":"2017-07-27T14:30:26.615Z","comments":true,"path":"2017/07/27/HTTP协议/","link":"","permalink":"http://yoursite.com/2017/07/27/HTTP协议/","excerpt":"1. HTTP简介1.1 简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。","text":"1. HTTP简介1.1 简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 1.2 HTTP 工作原理HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。Web服务器根据接收到的请求后，向客户端发送响应信息。HTTP默认端口号为80，但是你也可以改为8080或者其他端口。HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 以下图表展示了HTTP协议通信流程： 2 HTTP消息结构HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 2.1 客户端请求消息客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。 2.2 服务器相应消息HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 2.3 实例下面实例是一点典型的使用GET来传递数据的实例：客户端请求：1234567891011121314151617181920GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 Host: www.example.com Accept-Language: en, mi ``` 服务器响应```htmlHTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: Apache Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: \"34aa387-d-1568eb00\" Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain ``` 输出结果：``` javaHello World! My payload includes a trailing CRLF. 3. HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET: 请求指定的页面信息，并返回实体主体。 HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT: 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE:请求服务器删除指定的页面。 CONNECT:HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS:允许客户端查看服务器的性能。 TRACE:回显服务器收到的请求，主要用于测试或诊断。 4. HTTP 响应头信息HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。在本章节中我们将具体来介绍HTTP响应头信息。 Allow:服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding:文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length:表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type:表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date:当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires:应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified:文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location:表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh:表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server:服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie:设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate:客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 5. 状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。 当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。下面是常见的HTTP状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 HTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 1**：信息，服务器收到请求，需要请求者继续执行操作 2**：成功，操作被成功接收并处理 3**：重定向，需要进一步的操作以完成请求 4**：客户端错误，请求包含语法错误或无法完成请求 5**：服务器错误，服务器在处理请求的过程中发生了错误 HTTP content-typeContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。","categories":[],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"http://yoursite.com/tags/HTTP协议/"},{"name":"协议","slug":"协议","permalink":"http://yoursite.com/tags/协议/"}]},{"title":"TCP/IP协议","slug":"TCP-IP协议","date":"2017-07-27T13:22:50.000Z","updated":"2017-07-27T13:54:56.852Z","comments":true,"path":"2017/07/27/TCP-IP协议/","link":"","permalink":"http://yoursite.com/2017/07/27/TCP-IP协议/","excerpt":"1. TCP/IP 介绍1.1 计算机通信协议（Computer Communication Protocol）计算机通信协议是对那些计算机必须遵守以便彼此通信的的规则的描述。 1.2 什么是TCP/IPTCP/IP 是供已连接因特网的计算机进行通信的通信协议。TCP/IP 指传输控制协议/网际协议（Transmission Control Protocol / Internet Protocol）。TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。","text":"1. TCP/IP 介绍1.1 计算机通信协议（Computer Communication Protocol）计算机通信协议是对那些计算机必须遵守以便彼此通信的的规则的描述。 1.2 什么是TCP/IPTCP/IP 是供已连接因特网的计算机进行通信的通信协议。TCP/IP 指传输控制协议/网际协议（Transmission Control Protocol / Internet Protocol）。TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。 1.3 TCP/IP内部在 TCP/IP 中包含一系列用于处理数据通信的协议： TCP (传输控制协议) - 应用程序之间通信 UDP (用户数据报协议) - 应用程序之间的简单通信 IP (网际协议) - 计算机之间的通信 ICMP (因特网消息控制协议) - 针对错误和状态 DHCP (动态主机配置协议) - 针对动态寻址1.4 TCP 使用固定的连接TCP 用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方”握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。1.5 IP是无连接的IP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。1.6 IP路由器当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。IP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。1.7 TCP/IPTCP/IP 意味着 TCP 和 IP 在一起协同工作。TCP 负责应用软件（比如您的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。IP 负责将包发送至接受者。2. TCP/IP 寻址TCP/IP 使用 32 个比特或者 4 组 0 到 255 之间的数字来为计算机编址。2.1 IP地址每个计算机必须有一个 IP 地址才能够连入因特网。每个 IP 包必须有一个地址才能够发送到另一台计算机。在本教程下一节，您会学习到更多关于 IP 地址和 IP 名称的知识。2.2 IP地址包含4组数字 TCP/IP 使用 4 组数字来为计算机编址。每个计算机必须有一个唯一的 4 组数字的地址。每组数字必须在 0 到 255 之间，并由点号隔开，比如：192.168.1.60。 2.3 32 比特 = 4 字节TCP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。一个计算机字节可以包含 256 个不同的值：00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ……. 直到 11111111。现在，您应该知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 组数字。 2.4 IP V6IPv6 是 “Internet Protocol Version 6” 的缩写，也被称作下一代互联网协议，它是由 IETF 小组（Internet 工程任务组Internet Engineering Task Force）设计的用来替代现行的 IPv4（现行的）协议的一种新的 IP 协议。我们知道，Internet 的主机都有一个唯一的 IP 地址，IP 地址用一个 32 位二进制的数表示一个主机号码，但 32 位地址资源有限，已经不能满足用户的需求了，因此 Internet 研究组织发布新的主机标识方法，即 IPv6。在 RFC1884 中（RFC 是 Request for Comments document 的缩写。RFC 实际上就是 Internet 有关服务的一些标准），规定的标准语法建议把 IPv6 地址的 128 位（16 个字节）写成 8 个 16 位的无符号整数，每个整数用 4 个十六进制位表示，这些数之间用冒号（:）分开，例如：123456789101112131415686E：8C64：FFFF：FFFF：0：1180：96A：FFFF``` 冒号十六进制记法允许零压缩，即一串连续的0可以用一对冒号取代，例如： ```javaFF05：0：0：0：0：0：0：B3可以定成：FF05：：B3``` 为了保证零压缩有一个清晰的解释，建议中规定，在任一地址中，只能使用一次零压缩。该技术对已建议的分配策略特别有用，因为会有许多地址包含连续的零串。 冒号十六进制记法结合有点十进制记法的后缀。这种结合在IPv4向IPv6换阶段特别有用。例如，下面的串是一个合法的冒号十六进制记法：```java0：0：0：0：0：0：128.10.1.1``` 这种记法中，虽然冒号所分隔的每一个值是一个16位的量，但每个分点十进制部分的值则指明一个字节的值。再使用零压缩即可得出： ```java：：128.10.1.1 2.5 域名12 个阿拉伯数字很难记忆。使用一个名称更容易。用于 TCP/IP 地址的名字被称为域名。runoob.com 就是一个域名。当你键入一个像 http://www.runoob.com 这样的域名，域名会被一种 DNS 程序翻译为数字。在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。当一个新的域名连同其 TCP/IP 地址一起注册后，全世界的 DNS 服务器都会对此信息进行更新。 3. TCP/IP 协议TCP/IP 是不同的通信协议的大集合。 3.1 协议族TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。 3.2 TCP - 传输控制协议TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。 3.3 IP - 网际协议（Internet Protocol）IP 负责计算机之间的通信。IP 负责在因特网上发送和接收数据包。 3.4 HTTP - 超文本传输协议(Hyper Text Transfer Protocol)HTTP 负责 web 服务器与 web 浏览器之间的通信。HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。 3.5 HTTPS - 安全的 HTTP（Secure HTTP）HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。 3.6 SSL - 安全套接字层（Secure Sockets Layer）SSL 协议用于为安全数据传输加密数据。 3.7 SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）SMTP 用于电子邮件的传输。 3.8 MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。 3.9 IMAP - 因特网消息访问协议（Internet Message Access Protocol）IMAP 用于存储和取回电子邮件。 3.10 POP - 邮局协议（Post Office Protocol）POP 用于从电子邮件服务器向个人电脑下载电子邮件。 3.11 FTP - 文件传输协议（File Transfer Protocol）FTP 负责计算机之间的文件传输。 3.12 NTP - 网络时间协议（Network Time Protocol）NTP 用于在计算机之间同步时间（钟）。 3.13 DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）DHCP 用于向网络中的计算机分配动态 IP 地址。 3.14 SNMP - 简单网络管理协议（Simple Network Management Protocol）SNMP 用于计算机网络的管理。 3.15 LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。 3.16 ICMP - 因特网消息控制协议（Internet Control Message Protocol）ICMP 负责网络中的错误处理。 3.17 ARP - 地址解析协议（Address Resolution Protocol）ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。 3.18 RARP - 反向地址转换协议（Reverse Address Resolution Protocol）RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。 3.19 BOOTP - 自举协议（Boot Protocol）BOOTP 用于从网络启动计算机。 3.20 PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）PPTP 用于私人网络之间的连接（隧道）。 4. TCP/IP 邮件电子邮件是 TCP/IP 最重要的应用之一。 4.1 您不会用到…当您写邮件时，您不会用到 TCP/IP。当您写邮件时，您用到的是电子邮件程序，例如莲花软件的 Notes，微软公司出品的 Outlook，或者 Netscape Communicator 等等。 4.2 邮件程序会用到…您的电子邮件程序使用不同的 TCP/IP 协议： 使用 SMTP 来发送邮件 使用 POP 从邮件服务器下载邮件 使用 IMAP 连接到邮件服务器4.3 SMTP - 简单邮件传输协议SMTP 协议用于传输电子邮件。SMTP 负责把邮件发送到另一台计算机。通常情况下，邮件会被送到一台邮件服务器（SMTP 服务器），然后被送到另一台（或几台）服务器，然后最终被送到它的目的地。SMTP 也可以传送纯文本，但是无法传输诸如图片、声音或者电影之类的二进制数据。SMTP 使用 MIME 协议通过 TCP/IP 网络来发送二进制数据。MIME 协议会将二进制数据转换为纯文本。 4.4 POP - 邮局协议POP 协议被邮件程序用来取回邮件服务器上面的邮件。假如您的邮件程序使用 POP，那么一旦它连接上邮件服务器，您的所有的邮件都会被下载到邮件程序中（或者称之为邮件客户端）。4.5 IMAP - 因特网消息访问协议与 POP 类似，IMAP 协议同样被邮件程序使用。IMAP 协议与 POP 协议之间的主要差异是：如果 IMAP 连上了邮件服务器，它不会自动地将邮件下载到邮件程序之中。IMAP 使您有能力在下载邮件之前先通过邮件服务器端查看他们。通过 IMAP，您可以选择下载这些邮件或者仅仅是删除它们。比方说您需要从不同的位置访问邮件服务器，但是仅仅希望回到办公室的时候再下载邮件，IMAP 在这种情况下会很有用。","categories":[{"name":"传输协议","slug":"传输协议","permalink":"http://yoursite.com/categories/传输协议/"},{"name":"TCP/IP","slug":"传输协议/TCP-IP","permalink":"http://yoursite.com/categories/传输协议/TCP-IP/"}],"tags":[{"name":"传输协议","slug":"传输协议","permalink":"http://yoursite.com/tags/传输协议/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"hexo博客搭建","slug":"hexo博客搭建","date":"2017-07-21T09:16:00.000Z","updated":"2017-07-21T09:28:14.920Z","comments":true,"path":"2017/07/21/hexo博客搭建/","link":"","permalink":"http://yoursite.com/2017/07/21/hexo博客搭建/","excerpt":"搭建过程具体搭建过程参照为知笔记内容。","text":"搭建过程具体搭建过程参照为知笔记内容。 博客源码百度云+github","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"hexo博客加入图片","slug":"hexo博客加入图片","date":"2017-07-21T08:52:36.000Z","updated":"2017-07-21T09:28:27.271Z","comments":true,"path":"2017/07/21/hexo博客加入图片/","link":"","permalink":"http://yoursite.com/2017/07/21/hexo博客加入图片/","excerpt":"例如： 准备工作","text":"例如： 准备工作 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 如何使用 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 注意：xxxx是这个md文件的名字，也是同名文件夹的名字，你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 最后检查一下，hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看相关字段，可以发现，html标签内的语句是，而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"插入图片","slug":"插入图片","permalink":"http://yoursite.com/tags/插入图片/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2017-07-21T02:28:55.000Z","updated":"2017-07-21T16:31:12.249Z","comments":true,"path":"2017/07/21/SpringMVC/","link":"","permalink":"http://yoursite.com/2017/07/21/SpringMVC/","excerpt":"1.SpringMVC有什么用 表现层，负责接收用户的数据和分配处理以及分发转向 处理流程：","text":"1.SpringMVC有什么用 表现层，负责接收用户的数据和分配处理以及分发转向 处理流程： 2.入门程序 创建web工程 导入jar包 创建listItem.jsp 创建ItemController，temController是一个普通的java类，不需要实现任何接口，只需要在类上添加@Controller注解即可。@RequestMapping注解指定请求的url，其中“.action”可以加也可以不加。在ModelAndView对象中，将视图设置为“/WEB-INF/jsp/itemList.jsp” 1234567891011121314151617181920212223242526272829303132@Controllerpublicclass ItemController &#123; @RequestMapping(\"/itemList\") public ModelAndView itemList() throws Exception &#123; List&lt;Items&gt;itemList = new ArrayList&lt;&gt;(); //商品列表 Items items_1 = new Items(); items_1.setName(\"联想笔记本_3\"); items_1.setPrice(6000f); items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\"); Items items_2 = new Items(); items_2.setName(\"苹果手机\"); items_2.setPrice(5000f); items_2.setDetail(\"iphone6苹果手机！\"); itemList.add(items_1); itemList.add(items_2); //创建modelandView对象 ModelAndView modelAndView = new ModelAndView(); //添加model modelAndView.addObject(\"itemList\", itemList); //添加视图 modelAndView.setViewName(\"/WEB-INF/jsp/itemList.jsp\");// modelAndView.setViewName(\"itemsList\"); returnmodelAndView; &#125;&#125; 创建SpringMVC.xml，相当于struts中的struts.xml进行配置转向 12345678910111213&lt;?xmlversion=\"1.0\"encoding=\"UTF-8\"?&gt;&lt;beansxmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;context:component-scanbase-package=\"cn.itcast.springmvc.controller\"/&gt; &lt;/beans&gt; 配置前端控制器，在web.xml中添加DispatcherServlet的配置。 12345678910111213&lt;!-- 前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.SpringMVC架构架构流程 用户发送请求 前端控制器接收 控制器把请求发送给处理器映射器，（url到请求方法的映射）@RequestMapping(/abc),它的内部就类似于一个hashMap 返回处理器执行莲(拦截器，拦截请求，主要在权限的时候用)，拦住了就不执行方法，没拦住就执行方法并返回handler处理器给前端控制器 前端发送handler给处理器适配器，由适配器按照用户的要求是用注解或非注解的形式去调用controller中的handler (注意)适配器就是注解与否，handler就是类似于action的controller 处理器适配器就是，根据不同的handler找到不同的处理器适配器去执行handler-handler处理器进行controller处理，返回ModelAndView，model放的是返回个页面的数据，View装的是返回到哪个页面 modelAndView返回到前端控制器， 前端控制器接着找到视图解析器，让视图解析器解析视图（springMVC特有的） 视图最常见的是jsp，pdf，freemarker等也算，但是动态网站都是动态加载，但是慢，静态网站就是加载比较快，所以有了freemarker模板 视图解析器根据不同的视图进行解析，返回view对象 解析完之后，进行视图的渲染，拼成html 将html返回给用户 我们要写的有哪些？ handler（controller） 分配什么适配器，具体的适配器不需要我们写 视图,也就是页面4.SpringMVC整合Mybatis5.参数绑定6.高级参数绑定7.Spring注解以及@RequestMapping注解的使用8.Controller返回值9.异常处理10.上传图片11.Json交互12.SpringMVC实现Restful13.拦截器","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"控制层","slug":"控制层","permalink":"http://yoursite.com/tags/控制层/"}]},{"title":"Git入门","slug":"Git入门","date":"2017-07-17T11:27:47.206Z","updated":"2017-07-20T08:36:08.775Z","comments":true,"path":"2017/07/17/Git入门/","link":"","permalink":"http://yoursite.com/2017/07/17/Git入门/","excerpt":"1. 创建版本库 创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： 通过git init命令把这个目录变成Git可以管理的仓库 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 2. 版本库添加文件","text":"1. 创建版本库 创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： 通过git init命令把这个目录变成Git可以管理的仓库 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 2. 版本库添加文件 用命令git add告诉Git，把文件添加到仓库:git add readme.txt 提交文件:git commit -m “add 3 files.” 3. 查看当前仓库状态git status: 命令可以让我们时刻掌握仓库当前的状态 4. 查看差异 git diff readme.txt 5. 查看历史版本记录git log命令显示从最近到最远的提交日志 6. 版本回退每提交一个新版本，实际上Git就会把它们自动串成一条时间线。现在准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令： $ git reset –hard HEAD^ HEAD is now at ea34578 add distributed 7. 重新恢复到新版本 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 只要右侧环境还在，就可以找到那个append GPL的commit id是3628164…，于是就可以指定回到未来的某个版本： $ git reset –hard 3628164 HEAD is now at 3628164 append GPL 8. 查看文本内容$ cat readme.txt. 9. 命令记录 git reflog：用来记录你的每一次命令 10. 工作区工作区：就是你在电脑里能看到的目录,learngit文件夹就是一个工作区，比如我们环境中当前的目录。 11. 版本库和暂存区 版本库:工作区有一个隐藏目录.git 这个不算工作区，而是Git的版本库。 暂存区：英文叫stage,或index。一般存放在git 目录下的index文件(.git/index)中，所以我们把暂存区时也叫作索引(index). Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD 12 版本库添加文件时的步骤 第一步是用git add把文件（工作区的）添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支（仓库）。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以现在git commit就是往master分支上提交更改。Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 13 管理修改把需要进行提交的修改add到暂存区中，最后会在commit提交时git将修改放入到仓库中 14. 撤销修改 如果你在readme.txt中加入了一行文件，又感觉不好，你可以删除新加的，恢复到原来的。 Git会告诉你，git checkout – file可以丢弃工作区的修改： git checkout -- readme.txt 意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 15. 修改总结 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步： 第一步用命令git reset HEAD file，就回到了1； 第二步按1操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库 16. 删除文件 rm test.txt： 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 现在你有两个选择， 一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 17. 远程仓库 ssh方式连接远程仓库 创建SSH Key。在当前目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登陆GitHub，打开“Account settings”，“SSH Keys”页面： 18. GitHub创建新仓库 GitHub创建一个Git仓库,并且本地仓库与此仓库进行远程同步，此仓库既可以作为备份，又可以让其他人通过该仓库来协作。 19. 关联远程仓库 git remote add origin git@github.com:onlyone/learngit.git：请千万注意，把上面的onlyone替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 20. 本地内容推送远程仓库 本地库的所有内容推送到远程库上：git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从现在起，只要本地作了提交，就可以通过命令：git push origin master：把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 1.总结： 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；关联后，使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 21. 第一次SSH警告 The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established. 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 22. 从远程库克隆 从远程库克隆,就需要我们先创建远程库，在github创建一个新的gitskills仓库，我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：git clone git@github.com:michaelliao/gitskills.git 你也许还注意到，GitHub给出的地址不止一个，还可以用github.com/onlyone/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 注意：要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 23. 分支管理 在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长，当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 现在对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 24. 创建分支 首先，我们创建dev分支，然后切换到dev分支：git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：git branch dev + git checkout dev 然后，用git branch命令查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号：git branch 然后提交：git add readme.txt + git commit -m &quot;branch test&quot; dev分支的工作完成，我们就可以切换回master分支：git checkout master 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 25. 合并分支 我们把前面dev分支的工作成果合并到master分支上：git merge dev it merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 26. 删除分支 合并完成后，就可以放心地删除dev分支了：git branch -d dev 删除后，查看branch，就只剩下master分支了：git branch 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 27. 总结分支指令 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 28. 产生冲突 当我们进行合并分支往往会产生冲突。 在准备新的feature1分支，继续我们的新分支开发：$ git checkout -b feature1 修改readme.txt最后一行，改为Creating a new branch is quick AND simple. 在feature1分支上提交：$ git add readme.txt $ git commit -m &quot;AND simple&quot; 切换到master分支：$ git checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为Creating a new branch is quick &amp; simple.提交：git add readme.txt $ git commit -m &quot;&amp; simple&quot; 此时，如果master和feature1合并，那么就可能产生冲突 29. 解决冲突 Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，执行git merge feature1,在看readme.txt： 我们把冲突的内容修改为Creating a new branch is quick and simple.，提交： $ git add readme.txt $ git commit -m &quot;conflict fixed&quot; 用带参数的git log也可以看到分支的合并情况：$ git log --graph --pretty=oneline --abbrev-commit 最后，删除feature1分支：$ git branch -d feature1 冲突解决，最后，删除feature1分支 git branch -d feature1，当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 30. bug分支 如果你有一个bug任务，你想创建一个分支issue-101来修复它，但是你当前正在dev上进行的工作还没有完成而不能提交，bug需要现在修复，所以现在你需要暂停dev上工作，Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：$ git stash。 假定需要在master分支上修复，就从master创建临时分支： $ git checkout master $ git checkout -b issue-101 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： $ git add readme.txt $ git commit -m &quot;fix bug 101&quot; 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： $ git checkout master $ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 $ git branch -d issue-101 Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了：30. Feature分支 在软件开发中，总会添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在新功能开发代号为Vulcan:$ git checkout -b feature-vulcan 开发完毕，添加并提交： $ git add vulcan.py $ git commit -m &quot;add feature vulcan&quot; 切回dev，准备合并：$ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 由于种种原因，此功能又不需要了，现在这个分支需要就地销毁：$ git branch -d feature-vulcan 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。 现在我们强行删除：$ git branch -D feature-vulcan 注意：开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 31. 推送分支 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程仓库的默认名称是origin。 要查看远程库的信息，用git remote,或者，用git remote -v显示更详细的信息： 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： git push origin master 如果要推送其他分支，比如dev，就改成:git push origin dev 分支总结 master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 32. 多人协作 多人协作时，大家都会往master和dev分支上推送各自的修改。当你的同事也克隆一份此项目从远程库，默认情况下，只能看到本地的master分支。现在，你的同事要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程，并且已经向origin/dev分支推送了他的提交，这时你也对同样的文件作了修改，并试图推送，推送失败，因为你的同事的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送，git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接。 这回git pull成功，但是是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：$ git commit -m &quot;merge &amp; fix hello.py&quot; $ git push origin dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 33. 标签 标签的作用 发布版本时，通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像，但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 创建标签 首先，切换到需要打标签的分支上：$ git checkout master 然后，敲命令git tag 就可以打一个新标签：$ git tag v1.0 默认标签是打在最新提交的commit上的。还可以对历史提交打上标签，只要找到历史提交的commit id，然后打上就可以了，例如要对add merge这次提交打标签，它对应的commit id是6224937，输入命令：$ git tag v0.9 6224937 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 用命令git show 可以看到说明文字：$ git show v0.1 签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：gpg: signing failed: secret key not available 如果报错，请参考GnuPG帮助文档配置Key。 命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签； 命令git tag可以查看所有标签。 操作标签 如果标签打错了，也可以删除：$ git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;: $ git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签：$ git push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：$ git tag -d v0.9 然后，从远程删除。删除命令也是push，但是格式如下：$ git push origin : refs/tags/v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 总结： git push origin &lt;tagname&gt;可以推送一个本地标签； git push origin --tags可以推送全部未推送过的本地标签； git tag -d &lt;tagname&gt;可以删除一个本地标签； git push origin : refs/tags/&lt;tagname&gt;可以删除一个远程标签。 34. github使用 GitHub不仅是免费的远程仓库，个人的开源项目，可以放到GitHub上，而且GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。 在GitHub上，利用Git极其强大的克隆和分支功能，人们可以自由参与各种开源项目。比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，在它的项目主页，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone。一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。 Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库 如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。 35. git忽略文件 有些时候我们需要把一些文件例如：保存了数据库密码的配置文件放在Git目录下，但又不提交，那么需要我们在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 36. git使用别名 配置别名其实就是把命令重新设置简单些，方便输入，例如：如果输入git st就表示git status：$ git config --global alias.st status 现在都用co表示checkout，ci表示commit，br表示branch： $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch –global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 37. 配置文件 配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中： 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 38. 搭建Git服务器 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git：$ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务：$ sudo adduser git 第三步，创建证书登录：收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库：先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：$ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：$ sudo chown -R git:git sample.git 第五步，禁用shell登录：出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash 改为：git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库：现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：$ git clone git@server:/srv/sample.git 39. 管理公钥和管理权限 管理公钥：如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 管理权限：有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。 主要两点： 要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 …","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"版本库","slug":"版本库","permalink":"http://yoursite.com/tags/版本库/"}]},{"title":"SpringMVC 总结","slug":"Mybatis总结","date":"2017-07-12T07:08:32.000Z","updated":"2017-07-21T15:40:57.820Z","comments":true,"path":"2017/07/12/Mybatis总结/","link":"","permalink":"http://yoursite.com/2017/07/12/Mybatis总结/","excerpt":"1.Mybatis所处的位置Mybatis处在持久层，和数据库打交道 2.为什么需要Mybatis引入MyBatis的目的：主要是为了弥补JDBC的硬编码问题： 解决频发链接数据库 解决sql代码的硬编码 解决占位符硬编码 解决结果集硬编码","text":"1.Mybatis所处的位置Mybatis处在持久层，和数据库打交道 2.为什么需要Mybatis引入MyBatis的目的：主要是为了弥补JDBC的硬编码问题： 解决频发链接数据库 解决sql代码的硬编码 解决占位符硬编码 解决结果集硬编码 3.架构4.我们使用Mybatis需要做的事 配置SqlMapConfig.xml，Mybatis全局配置文件 mapper.xml,存放sql语句的文件 通过sqlSessionFactory获取session进行操作，但这些都是Mybatis环境帮我们做的 5.入门程序 创建java项目 创建lib目录导入jar 编写SqlMapConfig.xml文件，在classpath下创建SqlMapConfig.xml,它的任务是数据源、事务管理，但是在后面这些事都是Spring进行整合，所以后面它的工作只是配置mapper.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 编写po类,Po类作为mybatis进行sql映射使用，po类通常与数据库表对应 123456public class User &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 编写对应po类的映射文件，发现映射文件的名字可以和po的名字不一样,在classpath下的sqlmap目录下创建sql映射文件Users.xml 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"test\"&gt;&lt;/mapper&gt; SqlMapConfig导入映射文件,将Users.xml添加在SqlMapConfig.xml 123&lt;mappers&gt; &lt;mapper resource=\"sqlmap/User.xml\"/&gt;&lt;/mappers&gt; 在映射文件中编写sql语句,根据id查找用户信息，在user.xml中添加 1234567&lt;!-- 根据id获取用户信息 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"cn.itcast.mybatis.po.User\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;parameterType：定义输入到sql中的映射类型，#&#123;id&#125;表示使用preparedstatement设置占位符号并将输入变量id传到sql。resultType：定义结果映射类型。 编写测试程序 123456789101112131415161718192021222324252627282930313233343536373839public class Mybatis_first &#123; //会话工厂 private SqlSessionFactory sqlSessionFactory; @Before public void createSqlSessionFactory() throws IOException &#123; // 配置文件 String resource = \"SqlMapConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); &#125; // 根据 id查询用户信息 @Test public void testFindUserById() &#123; // 数据库会话实例 SqlSession sqlSession = null; try &#123; // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 User user = sqlSession.selectOne(\"test.findUserById\", 10); // 输出用户信息 System.out.println(user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; Mybatis和Hibernate的区别Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 SqlSession和SqlSessionFactoryBuilder以及SqlSessionFactory SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。SqlSession是一个面向用户的接口， sqlSession中定义了数据库操作方法。每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。 SqlSessionFactoryBuilder用于创建SqlSessionFacoty，SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory生产，所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。 SqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。 在DAO中使用Mybatis进行开发 传统方式：该方式需要定义dao接口和实现类 编写接口和实现类 编写映射文件User.xml并根据需要，码上sql语句 传统方式存在的问题： Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法 调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不利于开发维护。 原始DAO开发流程 创建Java工程 创建lib目录并导入jar包 编写SqlMapConfig.xml 编写po类和对应的映射文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"test\"&gt;&lt;!-- 根据id获取用户信息 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"cn.itcast.mybatis.po.User\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;!-- 添加用户 --&gt; &lt;insert id=\"insertUser\" parameterType=\"cn.itcast.mybatis.po.User\"&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt; 编写UserDao接口和实现类，其实就是dao分担了测试程序的通过sqlsession进行操作的东西 1234567891011121314151617181920212223242526272829303132333435363738394041Public interface UserDao &#123; public User getUserById(int id) throws Exception; public void insertUser(User user) throws Exception;&#125;Public class UserDaoImpl implements UserDao &#123; //注入SqlSessionFactory public UserDaoImpl(SqlSessionFactory sqlSessionFactory)&#123; this.setSqlSessionFactory(sqlSessionFactory); &#125; private SqlSessionFactory sqlSessionFactory; @Override public User getUserById(int id) throws Exception &#123; SqlSession session = sqlSessionFactory.openSession(); User user = null; try &#123; //通过sqlsession调用selectOne方法获取一条结果集 //参数1：指定定义的statement的id,参数2：指定向statement中传递的参数 user = session.selectOne(\"test.findUserById\", 1); System.out.println(user); &#125; finally&#123; session.close(); &#125; return user; &#125; @Override Public void insertUser(User user) throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; sqlSession.insert(\"insertUser\", user); sqlSession.commit(); &#125; finally&#123; session.close(); &#125; &#125;&#125; 在实现类中，责任便是之前在测试类中的通过SqlSession来进行业务处理，除了加载全局配置文件以外——这就是Dao的目的，就是代替之前测试类干的事儿 编写测试类12345678910111213141516private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; SqlSessionFactoryBuilder sessionFactoryBuilder = new SqlSessionFactoryBuilder(); InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); sqlSessionFactory = sessionFactoryBuilder.build(inputStream); &#125; @Test public void testGetUserById() &#123; UserDao userDao = new UserDaoImpl(sqlSessionFactory); User user = userDao.getUserById(22); System.out.println(user); &#125;&#125; 使用原生dao开发的弊端 Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法 调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不利于开发维护。 使用Mapper动态代理的方式Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper代理方式需要遵循的规范： Mapper.xml文件中的namespace与mapper接口的类路径相同。 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 Mapper方式的开发步骤 创建Java项目 创建lib目录并导入jar包 创建PO类文件 编写全局配置文件 创建Mapper接口（相当于Dao开发中的接口） 1234567891011/** * 用户管理mapper */Public interface UserMapper &#123; //根据用户id查询用户信息 public User findUserById(int id) throws Exception; //查询用户列表 public List&lt;User&gt; findUserByUsername(String username) throws Exception; //添加用户信息 public void insertUser(User user)throws Exception; &#125; 创建和Mapper接口对应的映射文件，注意规范,XxxMapper.xml(映射文件) 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.itcast.mybatis.mapper.UserMapper\"&gt;&lt;!-- 根据id获取用户信息 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"cn.itcast.mybatis.po.User\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;!-- 自定义条件查询用户列表 --&gt; &lt;select id=\"findUserByUsername\" parameterType=\"java.lang.String\" resultType=\"cn.itcast.mybatis.po.User\"&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt;&lt;!-- 添加用户 --&gt; &lt;insert id=\"insertUser\" parameterType=\"cn.itcast.mybatis.po.User\"&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt; 加载配置文件 1234&lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt; 编写测试类 12345678910111213141516171819202122232425Public class UserMapperTest extends TestCase &#123; private SqlSessionFactory sqlSessionFactory; protected void setUp() throws Exception &#123; //mybatis配置文件 String resource = \"sqlMapConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); //使用SqlSessionFactoryBuilder创建sessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; Public void testFindUserById() throws Exception &#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 UserMapper userMapper = session.getMapper(UserMapper.class); //调用代理对象方法 User user = userMapper.findUserById(1); System.out.println(user); //关闭session session.close(); &#125; 其他为知笔记","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/categories/Mybatis/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"持久层","slug":"持久层","permalink":"http://yoursite.com/tags/持久层/"},{"name":"Spring整合","slug":"Spring整合","permalink":"http://yoursite.com/tags/Spring整合/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-09T04:54:32.516Z","updated":"2017-07-20T07:03:19.812Z","comments":true,"path":"2017/07/09/hello-world/","link":"","permalink":"http://yoursite.com/2017/07/09/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"MarkDown基本格式 — Power By Hexo","slug":"博客发布","date":"2017-02-10T15:49:28.000Z","updated":"2017-07-21T09:13:25.982Z","comments":true,"path":"2017/02/10/博客发布/","link":"","permalink":"http://yoursite.com/2017/02/10/博客发布/","excerpt":"语法","text":"语法 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 Hexo添加标签 思路：创建一个文件夹里面有index.md文件，主要是通过每次发布的博客文件中加入tags标签，并加上相应的标签名。最后通过导航找到 hexo new page tags，生成指定的tags文件夹目录和index.md文件 确认站点配置文件里有tag_dir: tags 确认主题配置文件里有tags: /tags 编辑站点的source/tags/index.md，添加1234title: tagsdate: 2015-10-20 06:49:50type: \"tags\"comments: false Hexo分类 思路：和标签的一样 hexo new page categories 确认站点配置文件里有category_dir: categories 确认主题配置文件里有categories: /categories 编辑站点的source/categories/index.md，添加1234title: categoriesdate: 2015-10-20 06:49:50type: \"categories\"comments: false Hexo的格式（易错，和next不一样）每次新建一个博客md文件时，如果需要加上标签，那么就需要加上123456tags: - tag1 - tag2categorys: - c1 - c2 Hexo博客发布 git add . git commit -m “git” git push -u origin blog-source hexo clean &amp;&amp; hexo g -d（好像自动发布的插件不起作用了）","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/categories/MarkDown/"},{"name":"hexo","slug":"MarkDown/hexo","permalink":"http://yoursite.com/categories/MarkDown/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]}]}